// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { AbortError } from "@azure/abort-controller";
import { OperationTimeoutError } from "rhea-promise";
import { StandardAbortMessage } from "@azure/core-amqp";
/**
 * An executor for a function that returns a Promise that obeys both a timeout and an
 * optional AbortSignal.
 * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.
 * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 *
 * @internal
 */
export function waitForTimeoutOrAbortOrResolve(args) {
    return __awaiter(this, void 0, void 0, function* () {
        if (args.abortSignal && args.abortSignal.aborted) {
            throw new AbortError(StandardAbortMessage);
        }
        let timer = undefined;
        let clearAbortSignal = undefined;
        const clearAbortSignalAndTimer = () => {
            var _a, _b;
            ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.clearTimeoutFn) !== null && _b !== void 0 ? _b : clearTimeout)(timer);
            if (clearAbortSignal) {
                clearAbortSignal();
            }
        };
        // eslint-disable-next-line promise/param-names
        const abortOrTimeoutPromise = new Promise((_resolve, reject) => {
            var _a, _b;
            clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);
            timer = ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.setTimeoutFn) !== null && _b !== void 0 ? _b : setTimeout)(() => {
                reject(new OperationTimeoutError(args.timeoutMessage));
            }, args.timeoutMs);
        });
        try {
            return yield Promise.race([abortOrTimeoutPromise, args.actionFn()]);
        }
        finally {
            clearAbortSignalAndTimer();
        }
    });
}
/**
 * @internal
 */
export function checkAndRegisterWithAbortSignal(onAbortFn, abortSignal) {
    if (abortSignal == null) {
        return () => {
            /** Nothing to do here, no abort signal */
        };
    }
    if (abortSignal.aborted) {
        throw new AbortError(StandardAbortMessage);
    }
    const onAbort = () => {
        abortSignal.removeEventListener("abort", onAbort);
        onAbortFn(new AbortError(StandardAbortMessage));
    };
    abortSignal.addEventListener("abort", onAbort);
    return () => abortSignal.removeEventListener("abort", onAbort);
}
//# sourceMappingURL=timeoutAbortSignalUtils.js.map