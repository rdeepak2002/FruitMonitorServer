{"version":3,"file":"timeoutAbortSignalUtils.js","sourceRoot":"","sources":["../../../src/util/timeoutAbortSignalUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC,OAAO,EAAE,UAAU,EAAmB,MAAM,yBAAyB,CAAC;AACtE,OAAO,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AACrD,OAAO,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAIxD;;;;;;;;;;GAUG;AACH,MAAM,UAAgB,8BAA8B,CAAI,IAUvD;;QACC,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE;YAChD,MAAM,IAAI,UAAU,CAAC,oBAAoB,CAAC,CAAC;SAC5C;QAED,IAAI,KAAK,GAAoB,SAAS,CAAC;QACvC,IAAI,gBAAgB,GAA6B,SAAS,CAAC;QAE3D,MAAM,wBAAwB,GAAG,GAAS,EAAE;;YAC1C,CAAC,MAAA,MAAA,IAAI,CAAC,gBAAgB,0CAAE,cAAc,mCAAI,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC;YAE/D,IAAI,gBAAgB,EAAE;gBACpB,gBAAgB,EAAE,CAAC;aACpB;QACH,CAAC,CAAC;QAEF,+CAA+C;QAC/C,MAAM,qBAAqB,GAAG,IAAI,OAAO,CAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,EAAE;;YAChE,gBAAgB,GAAG,+BAA+B,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YAE7E,KAAK,GAAG,CAAC,MAAA,MAAA,IAAI,CAAC,gBAAgB,0CAAE,YAAY,mCAAI,UAAU,CAAC,CAAC,GAAG,EAAE;gBAC/D,MAAM,CAAC,IAAI,qBAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACzD,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;QAEH,IAAI;YACF,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,qBAAqB,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;SACrE;gBAAS;YACR,wBAAwB,EAAE,CAAC;SAC5B;IACH,CAAC;CAAA;AAED;;GAEG;AACH,MAAM,UAAU,+BAA+B,CAC7C,SAA2C,EAC3C,WAA6B;IAE7B,IAAI,WAAW,IAAI,IAAI,EAAE;QACvB,OAAO,GAAG,EAAE;YACV,0CAA0C;QAC5C,CAAC,CAAC;KACH;IAED,IAAI,WAAW,CAAC,OAAO,EAAE;QACvB,MAAM,IAAI,UAAU,CAAC,oBAAoB,CAAC,CAAC;KAC5C;IAED,MAAM,OAAO,GAAG,GAAS,EAAE;QACzB,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAClD,SAAS,CAAC,IAAI,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC;IAEF,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAE/C,OAAO,GAAG,EAAE,CAAC,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACjE,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationTimeoutError } from \"rhea-promise\";\nimport { StandardAbortMessage } from \"@azure/core-amqp\";\n\ntype setTimeoutArgs = (callback: (...args: any[]) => void, ms: number, ...args: any[]) => any;\n\n/**\n * An executor for a function that returns a Promise that obeys both a timeout and an\n * optional AbortSignal.\n * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.\n * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.\n * @param abortSignal - The abortSignal associated with containing operation.\n * @param abortErrorMsg - The abort error message associated with containing operation.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n *\n * @internal\n */\nexport async function waitForTimeoutOrAbortOrResolve<T>(args: {\n  actionFn: () => Promise<T>;\n  timeoutMs: number;\n  timeoutMessage: string;\n  abortSignal?: AbortSignalLike;\n  // these are optional and only here for testing.\n  timeoutFunctions?: {\n    setTimeoutFn: setTimeoutArgs;\n    clearTimeoutFn: (timeoutId: any) => void;\n  };\n}): Promise<T> {\n  if (args.abortSignal && args.abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  let timer: any | undefined = undefined;\n  let clearAbortSignal: (() => void) | undefined = undefined;\n\n  const clearAbortSignalAndTimer = (): void => {\n    (args.timeoutFunctions?.clearTimeoutFn ?? clearTimeout)(timer);\n\n    if (clearAbortSignal) {\n      clearAbortSignal();\n    }\n  };\n\n  // eslint-disable-next-line promise/param-names\n  const abortOrTimeoutPromise = new Promise<T>((_resolve, reject) => {\n    clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);\n\n    timer = (args.timeoutFunctions?.setTimeoutFn ?? setTimeout)(() => {\n      reject(new OperationTimeoutError(args.timeoutMessage));\n    }, args.timeoutMs);\n  });\n\n  try {\n    return await Promise.race([abortOrTimeoutPromise, args.actionFn()]);\n  } finally {\n    clearAbortSignalAndTimer();\n  }\n}\n\n/**\n * @internal\n */\nexport function checkAndRegisterWithAbortSignal(\n  onAbortFn: (abortError: AbortError) => void,\n  abortSignal?: AbortSignalLike\n): () => void {\n  if (abortSignal == null) {\n    return () => {\n      /** Nothing to do here, no abort signal */\n    };\n  }\n\n  if (abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  const onAbort = (): void => {\n    abortSignal.removeEventListener(\"abort\", onAbort);\n    onAbortFn(new AbortError(StandardAbortMessage));\n  };\n\n  abortSignal.addEventListener(\"abort\", onAbort);\n\n  return () => abortSignal.removeEventListener(\"abort\", onAbort);\n}\n"]}